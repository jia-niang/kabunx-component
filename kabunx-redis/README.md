## Redis解决了什么问题？

大规模读写数据与数据库读写能力之间的矛盾

简单回顾一下CPU高速缓存的发展历程，为了解决CPU的计算速度与内存的读取速度之间的巨大差异，CPU使用高速缓存来存放指令和数据。高速缓存从最初的主板缓存到现在的3级缓存，缓存大小也不断变大。来自网络的数据表明：CPU高速缓存的命中率大约为80%。

类比电脑发展过程中CPU与内存的矛盾，可以察觉到大型网站中大规模读写数据与数据库读写能力之间的矛盾与此矛盾类似。我们也可以在数据库与应用之间构建一块比数据库速度更快存储区域——缓存。大家最熟悉的也莫过于Redis用作缓存，我们知道Redis的作者设计Redis的初衷是因为他使用关系型数据库时，无论如何优化，性能都不能达到自己的期望，于是便自己手写了一个内存数据库。

在作为缓存的情况下，我们有一下应用场景：

1. 热点数据 例如我们可以将SQL查询结果保存在内存中，也可以将用户经常查看的图片保存在内存中。
2. 排行榜
   基于Redis提供的zSet这种数据结构我们可以更加便捷的实现排行榜。实现排行榜的相关内容可以参考排行榜算法设计实现比较。在小规模数据的情况下，使用Mysql实现排行榜没有多少问题，但是一旦数据量上去了，那么持续的进行Mysql读写将会成为瓶颈。
3. 计数器/限速器
   计数器的应用场景之一是统计用户的点赞数，限速器的应用场景之一是限制用户ip的访问次数。之所以Redis能用于计数器是因为Redis是单线程的，每次都必须前一个指令执行完，再执行下一个指令。这样就保证不会同时执行多条指令；也即不会出现并发问题。限速器的原理类似。
4. 共同好友 利用Redis提供的Set数据结构的求交集操作sinter可以更加便捷地求两个Set集合的交集；而使用数据库的连表查询将造成性能的开销很多，因为大型网站的用户数量巨大。
5. 简单消息队列 Redis的提供的发布/订阅是一个极其简单的消息系统。它不像Kafka那样提供了分成不同的topic并且分成不同的分区并且提供持久化的功能。Ｒｅｄｉｓ的消息队列用在不需要高可靠的场景。

### 为什么使用redis？

分析:博主觉得在项目中使用redis，主要是从两个角度去考虑:
性能和并发。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(
如zooKeeper等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。

回答:如下所示，分为两点:

（一）性能

我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。

（二）并发

在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。

## SpringBoot 整合 Redis

### 依赖

在 pom.xml 文件中添加redis的starter，这里已经将连接池替换为Jedis

```xml

<dependency>
    <groupId>com.kabunx.component</groupId>
    <artifactId>redis-spring-boot-starter</artifactId>
</dependency>
```

### 配置

在 application.yml 文件中添加相关配置

```yaml
spring:
  redis:
    host: xxx.xxx.99.232 # Redis服务器地址
    database: 0 # Redis数据库索引（默认为0）
    port: 6379 # Redis服务器连接端口
    password: xxx # Redis服务器连接密码（默认为空）
    timeout: 1000 # 连接超时时间（毫秒）
```

### 使用连接池

Redis 是基于内存的数据库，本来是为了提高程序性能的，但如果不使用 Redis 连接池的话，建立连接、断开连接就需要消耗大量的时间。

用了连接池，就可以实现在客户端建立多个连接，需要的时候从连接池拿，用完了再放回去，这样就节省了连接建立、断开的时间。

要使用连接池，我们得先了解 Redis 的客户端，常用的有两种：Jedis（1.5.x默认） 和 Lettuce（2.x默认）。

#### Jedis

相关依赖，已在starter中引入，直接修改配置信息

```yaml
spring:
  redis:
    jedis:
      pool:
        max-active: 8 # 连接池最大连接数
        max-idle: 8 # 连接池最大空闲连接数
        min-idle: 0 # 连接池最小空闲连接数
        max-wait: -1 # 连接池最大阻塞等待时间，负值表示没有限制
```
