## 缓存

简单的理解，缓存就是将数据从读取较慢的介质上读取出来放到读取较快的介质上，如磁盘-->
内存。平时我们会将数据存储到磁盘上，如：数据库。如果每次都从数据库里去读取，会因为磁盘本身的 IO 影响读取速度，所以就有了像
redis 这种的内存缓存。可以将数据读取出来放到内存里，这样当需要获取数据时，就能够直接从内存中拿到数据返回，能够很大程度的提高速度。

## 为什么使用缓存

在高并发、大流量等场景下，降低系统延迟，缓解数据库压力，提高系统整体的性能，让用户有更好的体验。

## 使用场景

读多写少、不追求强一致性、请求入参不易变化。

## 现状

目前缓存的解决方案一般有两种：

* 内存缓存（如 Caffeine） —— 速度快，进程内可用
* 集中式缓存（如 Redis）—— 可同时为多节点提供服务

现有的缓存框架已经非常成熟而且优秀，那为什么还需要使用二级缓存呐？主要解决以下几个问题：

* 使用内存缓存时，一旦应用重启后，由于缓存数据丢失，缓存雪崩，给数据库造成巨大压力，导致应用堵塞
* 使用内存缓存时，多个应用节点无法共享缓存数据
* 使用集中式缓存，由于大量的数据通过缓存获取，导致缓存服务的数据吞吐量太大，带宽跑满。现象就是 Redis
  服务负载不高，但是由于机器网卡带宽跑满，导致数据读取非常慢

在遭遇问题 1、2 时，很多人自然而然会想到使用 Redis 来缓存数据，因此就难以避免的导致了问题 3 的发生。

当发生问题 3 时，又有很多人想到 Redis 的集群，通过集群来降低缓存服务的压力，特别是带宽压力。

但其实，这个时候的 Redis 上的数据量并不一定大，仅仅是数据的吞吐量大而已。

综合所述：我们需要构建 L1 Caffeine JVM 级别内存 ， L2 Redis 内存。

## 思考

L2Cache 缓存系统其实不是一个缓存框架，它更像是一个缓存框架的桥梁。它利用现有优秀的内存缓存框架作为一级缓存，而把 Redis
作为二级缓存。所有数据的读取先从一级缓存中读取，不存在时再从二级缓存读取，这样来确保对二级缓存 Redis 的访问次数降到最低。

有人会质疑说，那岂不是应用节点的内存占用要飙升？我的答案是 ——
现在服务器的内存已经非常便宜了，这点点的内存消耗完全不在话下。其次一级缓存框架可以通过配置来控制在内存中存储的数据量，所以不用担心内存溢出的问题。

剩下的另外一个问题就是，当缓存数据更新的时候，怎么确保每个节点内存中的数据是一致的。这恰恰是设计的核心所在。

目前提供两种节点间数据同步的方案 —— Redis Pub/Sub。当某个节点的缓存数据需要更新时，L2Cache 会通过 Redis
的消息订阅机制来通知集群内其他节点。当其他节点收到缓存数据更新的通知时，它会清掉自己内存里的数据，然后重新从
Redis 中读取最新数据。

## 现有技术

| 方案          | 支持度 | 实现难度 | 可维护性 | 可扩展性 | 潜在问题                  |
|-------------|-----|------|------|------|-----------------------|
| SpringCache | 低   | 中    | 易    | 高    | 需要自己扩展                |
| JetCache    | 高   | 中    | 易    | 中    | 不满足多租户                |
| J2Cache     | 中   | 中    | 易    | 中    | 集成到 SpringBoot，不满足多租户 |

### Spring Cache

spring cache 是 spring-context 包中提供的基于注解方式使用的缓存组件，定义了一些标准接口，通过实现这些接口，就可以通过在方法上增加注解来实现缓存。这样就能够避免缓存代码与业务处理耦合在一起的问题。spring
cache 的实现是使用 spring aop 中对方法切面（MethodInterceptor）封装的扩展，当然 spring aop 也是基于 Aspect 来实现的。

目前大部分应用缓存都是基于 Spring Cache 实现,基于注释（annotation）的缓存（cache）技术,存在的问题如下：

* Spring Cache 仅支持 单一的缓存来源，即：只能选择 Redis 实现或者 Caffeine 实现，并不能同时使用。
* 数据一致性：各层缓存之间的数据一致性问题，如应用层缓存和分布式缓存之前的数据一致性问题。
* 缓存过期：Spring Cache 不支持主动的过期策略
* cacheNullValues 默认为false 存在缓存穿透的风险，注意这个属性是被 final 修饰的。

## JetCache

### 简介

JetCache 是一个基于 Java 的缓存系统封装，提供统一的 API 和注解来简化缓存的使用。
JetCache 提供了比 SpringCache 更加强大的注解，可以原生的支持 TTL、两级缓存、分布式自动刷新，还提供了 Cache 接口用于手工缓存操作。
当前有四个实现：RedisCache、RedisLettuceCache、CaffeineCache、LinkedHashMapCache。

JetCache提供的核心能力包括：

* 提供统一的，类似 jsr-107 风格的 API 访问 Cache，并可通过注解创建并配置 Cache 实例
* 通过注解实现声明式的方法缓存，支持 TTL 和两级缓存
* 分布式缓存自动刷新，分布式锁 (2.2+)
* 分布式多级缓存场景，缓存更新后，自动让所有的 local cache 失效（2.7+）
* 支持异步 Cache API
* Spring Boot 支持
* Key 的生成策略和 Value 的序列化策略是可以定制的
* 针对所有 Cache 实例和方法缓存的自动统计

自动刷新和加载保护是 JetCache 的大杀器，对于加载开销比较大的对象，为了防止缓存未命中时的高并发访问打爆数据库。

## 补充知识

### Redis 发布订阅

发布订阅：消息发布者发布消息 和 消息订阅者接收消息，两者之间通过某种媒介联系起来

* 当一个客户端通过 PUBLISH 命令向订阅者发布消息的时候，称这个客户端为发布者publisher
* 当一个客户端通过subscribe 接收消息时，称这个客户端为 订阅者 subscriber

为了解耦发布者和订阅者之间的关系，Redis 使用了频道 channel (频道)
作为两者之间的中介，发布者直接把消息发送给 channel（频道），而 channel 负责把消息发送给订阅者，发布者和订阅者之间没有直接的联系，都不知道对方的存在

客户端发到频道的消息，将会被推送到所有订阅此频道的客户端

客户端不需要主动去获取消息，只需要订阅频道，这个频道的内容就会被推送过来
