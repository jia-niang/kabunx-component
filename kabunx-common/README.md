## 应用架构的本质
什么是架构？十个人可能有十个回答，架构在技术的语境下，就和架构师一样魔幻。

实际上，定义架构也没那么难，架构的本质，简单来说，就是要素结构。所谓的要素（Components）是指架构中的主要元素，结构是指要素之间的相互关系（Relationship）。

同样，对于应用架构而言，代码是其核心组成要素，结也就构就是这些代码该如何被组织，是要如何处理模块（Module）、组件（Component）、包（Package）和类（Class）之间的关系。简而言之，应用架构就是要解决代码要如何被组织的问题。

一个没有架构的应用系统，就像一堆随意堆放、杂乱无章的玩具，只有熵值，没有熵减。而一个有良好架构的应用系统，有章法、有结构，一切都显得紧紧有条。

好的组织架构会遵循一定的架构模式，大部分的组织都会按职能和业务来设计自己的架构。如果你反其道而行之，硬要把销售、财务和技术人员放在一个部门，就会显得很奇怪。

同样，好的应用架构，也遵循一些共同模式，不管是六边形架构、洋葱圈架构、整洁架构、还是COLA架构，都提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度。

应用架构的本质，就是要从繁杂的业务系统中提炼出共性，找到解决业务问题的最佳共同模式，为开发人员提供统一的认知，治理混乱。帮助应用系统“从混乱到有序”，COLA架构就是为此而生，其核心职责就是定义良好的应用结构，提供最佳实践。

### 分层结构
所有的复杂系统都会呈现出层级结构，管理如此，软件设计也不例外，你能想象如果网络协议不是四层，而是一层，意味着，你要在应用层去处理链路层的bit数据流会是怎样的情景吗？同样，应用系统处理复杂业务逻辑也应该是分层的，下层对上层屏蔽处理细节，每一层各司其职，分离关注点，而不是一个ServiceImpl解决所有问题。

对于一个典型的业务应用系统来说，COLA会做如下层次定义，每一层都有明确的职责定义：
1. 适配层（Adapter Layer）：负责对前端展示（web，wireless，wap）的路由和适配，对于传统B/S系统而言，adapter就相当于MVC中的controller；
2. 应用层（Application Layer）：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理，如果需要的话，发送消息通知等。层次是开放的，应用层也可以绕过领域层，直接访问基础实施层；
3. 领域层（Domain Layer）：主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Domain Entity）的方法对App层提供业务实体和业务逻辑计算。领域是应用的核心，不依赖任何其他层次；
4. 基础实施层（Infrastructure Layer）：主要负责技术细节问题的处理，比如数据库的CRUD、搜索引擎、文件系统、分布式服务的RPC等。此外，领域防腐的重任也落在这里，外部依赖需要通过gateway的转义处理，才能被上面的App层和Domain层使用。

#### 包结构
所谓的内聚，就是把功能类似的玩具放在一个盒子里，这样可以让应用结构清晰，极大的降低系统的认知成本和维护成本。

各个包结构的简要功能描述，如下表所示：

| 层次   | 包名  | 功能    | 必选 |
|------|-----|-------|---|
| Adapter层 | web | 处理页面请求的Controller | 否 |
| Adapter层 | wap | 处理wap端的适配	| 否 |
| App层 | service | 处理request，包括command和query	| 是 |
| App层 | runner | 处理定时任务	| 否 |
| Domain层 | model	 | 领域模型	| 否 |
| Domain层 | gateway | 领域网关，解耦利器	| 是 |
| Infra层 | gateway.impl | 网关实现	| 是 |
| Infra层 | mapper | ibatis数据库映射	| 否 |
| Infra层 | config | 配置信息	| 否 |
| Client SDK | api | 服务对外透出的API	| 是 |
| Client SDK | dto	 | 服务对外的DTO	| 是 |

你可能会有疑问，为什么Domain的model是可选的？因为COLA是应用架构，不是DDD架构。在工作中，很多同学问我领域模型要怎么设计，我的回答通常是：无有必要勿增实体。领域模型对设计能力要求很高，没把握用好，一个错误的抽象还不如不抽象，宁可不要用，也不要滥用，不要为了DDD而DDD。

问题的关键是要看，新增的模型没有给你带来收益。比如有没有帮助系统解耦，有没有提升业务语义表达能力的提升，有没有提升系统的可维护性和可测性等等。

模型虽然可选，但DDD的思想是一定要去学习和贯彻的，特别是统一语言、边界上下文、防腐层的思想，值得深入学习，仔细体会。实际上，COLA里面的很多设计思想都来自于DDD。其中就包括领域包的设计。

前面的包定义，都是功能维度的定义。为了兼顾领域维度的内聚性，我们有必要对包结构进行一下微调，即顶层包结构应该是按照领域划分，让领域内聚。

### 解耦
“高内聚，低耦合”这句话，你工作的越久，就越会觉得其有道理。

所谓耦合就是联系的紧密程度，只要有依赖就会有耦合，不管是进程内的依赖，还是跨进程的RPC依赖，都会产生耦合。依赖不可消除，同样，耦合也不可避免。我们所能做的不是消除耦合，而是把耦合降低到可以接受的程度。在软件设计中，有大量的设计模式，设计原则都是为了解耦这一目的。

在DDD中有一个很棒的解耦设计思想——防腐层（Anti-Corruption），简单说，就是应用不要直接依赖外域的信息，要把外域的信息转换成自己领域上下文（Context）的实体再去使用，从而实现本域和外部依赖的解耦。

在COLA中，我们把AC这个概念进行了泛化，将数据库、搜索引擎等数据存储都列为外部依赖的范畴。利用依赖倒置，统一使用gateway来实现业务领域和外部依赖的解耦。

## CQRS概述
CQRS是Command and Query Responsibility Segregation（命令查询职责分离）的缩写。 世上很多事情都比较复杂，但是我们只要进行一些简单的分类后，那么事情就简单了很多。

其基本思想在于，任何一个对象的方法可以分为两大类：
* 命令(Command):不返回任何结果(void)，但会改变对象的状态。
* 查询(Query):返回结果，但是不会改变对象的状态，对系统没有副作用。

### CRUD和CQRS对比
#### CRUD (Create, Read, Update, Delete) 增查改删，我们很多系统都是对数据的增查改删。
过去我们很多系统比较简单，基本上增加的数据就是你要查询的数据，所以很多时候其实一个简单的Excel就能搞定。 
而且增删改查也足够的简单，所以我们很多系统分层后在数据层Repository里仍是对单表的增删改查，这样对不少的系统都符合。

但是，系统规模稍微大一点，我们都知道我们的数据库里的数据模型很难和我们业务层需要的模型一致。 于是我们引入了Domain Model, Repository里就会做Domain Model的来回转换

同时我们在UI层要的数据，往往又和具体的Domain不同，这个时候我们又要定义一个ViewModel. 而这些ViewModel又是组合不同的DomainModel得来。

传统的代码里的问题：
* 领域里有很多分页和排序，尤其是Repository里
* 查询的方法里暴露了很多不应该有的领域模型的属性，因为需要组装DTO
* 如果使用ORM，预加载了很多数据以提高性能，但是占用大量内存，而且需要维护这些数据。
* 加载组合庞大的数据，比如页面是需要一个名字，我们也会把整个User数据取出来。
重要的原来把数据混在一起，复杂的查询相当难以优化。 尤其是数据库出现大量的Join 系统性能极速下降。

#### CQRS
我们仔细看CRUD, 其实可以更简单的分为读R和写(CUD), 我们想想大部分情况都是，一个方法要么是执行一个Command完成一个动作，要么就是查询返回数据。

当我们读写分离后，我们对应的代码也会分离。

#### 数据存储
写的一端需要保证事物，所以一般数据存储为第三范式；

读的一端一般都是反范式可以避免Join操作，这样我们只需要把数据存储为第一范式。
#### 扩展
大部分的系统里写数据要远远少于读数据，并且一般都是每次修改很少的一部分数据，所以在写这端扩展都不是特别紧迫，读数据基本都远大于写数据的次数， 所以扩展就更重要。 我们很难建立同一个Model 既能给写数据和读数据公用而且能够保证性能都比较好的。
#### 查询端
查询端由于只是读数据，那么所有的方法应该都是返回数据，而且返回的数据就是界面直接需要的DTO, 这样可以减少传统的方法中把DomainModel映射为ViewModel或者DTO. 同时可以减少传统的领域里的一些混乱。
#### 写端
由于把读分离出去，所以我们就只关注写，那么我们写这一段需要保证事物，数据输入的验证，另外一般写这一端都不需要及时的看到结果，所以大部分都需要一个void方法就可以，那么让我们系统异步就更加方便。这样使系统的扩展性大大增强。



## CompletableFuture原理与实践

### 背景

随着业务的持续发展，在系统中，各系统服务面临的压力也越来越大。作为链路的核心环节，业务对系统吞吐量的要求也越来越高。
应用聚合API服务是流量入口，所有客户端流量都会由其调度、聚合，对外面提供功能接口，对内调度各个下游服务获取数据进行聚合，具有鲜明的I/O密集型（I/O
Bound）特点。
在规模达千万级的情况下，使用同步加载方式的弊端逐渐显现，因此我们开始考虑将同步加载改为并行加载的可行性。

### 为何需要并行加载

客户端API服务是典型的I/O密集型（I/O Bound）服务。
