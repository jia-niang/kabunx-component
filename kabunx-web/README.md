## 接口设计

我们知道，开发一个服务的第一步就是设计接口。接口的设计需要考虑的点非常多，比如接口的命名、参数列表、包装结构体、接口粒度、版本策略、幂等性实现、同步异步处理方式等。

这其中，和接口设计相关比较重要的点有三个，分别是包装结构体、版本策略、同步异步处理方式。

### 接口的响应要明确表示接口的处理结果

为了将接口设计得更合理，我们需要考虑如下两个原则：

* 对外隐藏内部实现。虽然说收单服务调用订单服务进行真正的下单操作，但是直接接口其实是收单服务提供的，收单服务不应该“直接”暴露其背后订单服务的状态码、错误描述。
* 设计接口结构时，明确每个字段的含义，以及客户端的处理方式。

### 要考虑接口变迁的版本控制策略

接口不可能一成不变，需要根据业务需求不断增加内部逻辑。如果做大的功能调整或重构，涉及参数定义的变化或是参数废弃，导致接口无法向前兼容，这时接口就需要有版本的概念。在考虑接口版本策略设计时，我们需要注意的是，最好一开始就明确版本策略，并考虑在整个服务端统一版本策略。

#### 第一，版本策略最好一开始就考虑

既然接口总是要变迁的，那么最好一开始就确定版本策略。 比如，确定是通过 URL Path 实现，是通过 QueryString 实现，还是通过 HTTP
头实现。

```java
// 通过URL Path实现版本控制
@GetMapping("/v1/api/user")
public int right1(){
        return 1;
        }
// 通过QueryString中的version参数实现版本控制
@GetMapping(value = "/api/user", params = "version=2")
public int right2(@RequestParam("version") int version){
        return 2;
        }
// 通过请求头中的X-API-VERSION参数实现版本控制
@GetMapping(value = "/api/user", headers = "X-API-VERSION=3")
public int right3(@RequestHeader("X-API-VERSION") int version){
        return 3;
        }
```

这三种方式中，URL Path 的方式最直观也最不容易出错；QueryString 不易携带，不太推荐作为公开 API 的版本策略；HTTP
头的方式比较没有侵入性，如果仅仅是部分接口需要进行版本控制，可以考虑这种方式。

#### 第二，版本实现方式要统一

相比于在每一个接口的 URL Path 中设置版本号，更理想的方式是在框架层面实现统一。如果你使用 Spring 框架的话，可以按照下面的方式自定义
RequestMappingHandlerMapping 来实现。

在本项目中已给到具体的实现。

### 接口处理方式要明确同步还是异步

比如定义一个上传文件的接口， 接口要么是彻底的同步处理，要么是彻底的异步处理：

* 所谓同步处理，接口一定是同步上传原文件和缩略图的，调用方可以自己选择调用超时，如果来得及可以一直等到上传完成，如果等不及可以结束等待，下一次再重试；
* 所谓异步处理，接口是两段式的，上传接口本身只是返回一个任务 ID，然后异步做上传操作，上传接口响应很快，客户端需要之后再拿着任务
  ID 调用任务查询接口查询上传的文件 URL。

## 异常设计

### 第一个错误：有些技巧的同学可能会使用 AOP 来进行类似的“统一异常处理”

每层架构的工作性质不同，且从业务性质上异常可能分为业务异常和系统异常两大类，这就决定了很难进行统一的异常处理。

因此，我不建议在框架层面进行异常的自动、统一处理，尤其不要随意捕获异常。但，框架可以做兜底工作。

如果异常上升到最上层逻辑还是无法处理的话，可以以统一的方式进行异常转换，比如通过 @RestControllerAdvice +
@ExceptionHandler，来捕获这些“未处理”异常：

* 对于自定义的业务异常，以 Warn 级别的日志记录异常以及当前 URL、执行方法等信息后，提取异常中的错误码和消息等信息，转换为合适的
  API 包装体返回给 API 调用方；
* 对于无法处理的系统异常，以 Error 级别的日志记录异常和上下文信息（比如 URL、参数、用户 ID）后，转换为普适的“服务器忙，请稍后再试”异常信息，同样以
  API 包装体返回给调用方。

### 第二错误：捕获了异常后直接生吞

通常情况下，生吞异常的原因，可能是不希望自己的方法抛出受检异常，只是为了把异常“处理掉”而捕获并生吞异常，也可能是想当然地认为异常并不重要或不可能产生。但不管是什么原因，不管是你认为多么不重要的异常，都不应该生吞，哪怕是一个日志也好。

### 第三个错，丢弃异常的原始信息

我们来看两个不太合适的异常处理方式，虽然没有完全生吞异常，但也丢失了宝贵的异常信息。

### 第四个错，抛出异常时不指定任何消息

总之，如果你捕获了异常打算处理的话，除了通过日志正确记录异常原始信息外，通常还有三种处理模式：

* 转换，即转换新的异常抛出。对于新抛出的异常，最好具有特定的分类和明确的异常消息，而不是随便抛一个无关或没有任何信息的异常，并最好通过
  cause 关联老异常。
* 重试，即重试之前的操作。比如远程调用服务端过载超时的情况，盲目重试会让问题更严重，需要考虑当前情况是否适合重试。
* 恢复，即尝试进行降级处理，或使用默认值来替代原始数据。

## Spring 框架 IoC 和 AOP 是扩展的核心

IoC 和 AOP 的初衷是解耦和扩展。理解这两个核心技术，就可以让你的代码变得更灵活、可随时替换，以及业务组件间更解耦。

IoC，其实就是一种设计思想。使用 Spring 来实现 IoC，意味着将你设计好的对象交给 Spring 容器控制，而不是直接在对象内部控制。IoC
带来了更多的可能性。

Spring 相关问题的问题比较复杂，一方面是 Spring 提供的 IoC 和 AOP 本就灵活，另一方面 Spring Boot 的自动装配、Spring Cloud
复杂的模块会让问题排查变得更复杂。

* 在为类标记上 @Service 注解把类型交由容器管理前，首先评估一下类是否有状态，然后为 Bean 设置合适的 Scope。
* Bean 默认是单例的，所以单例的 Controller 注入的 Service 也是一次性创建的，即使 Service 本身标识了 prototype 的范围也没用。

AOP，体现了松耦合、高内聚的精髓，在切面集中实现横切关注点（缓存、权限、日志等），然后通过切点配置把代码注入合适的地方。切面、切点、增强、连接点，是
AOP 中非常重要的概念。

大多数情况下顺序并不是那么重要，但对于 AOP，顺序可能会引发致命问题。

对于 Bean 可以通过 @Order 注解来设置优先级，查看 @Order 注解和 Ordered 接口源码可以发现，默认情况下 Bean 的优先级为最低优先级，其值是
Integer 的最大值。

我们在使用 AOP 的时候，要特别注意顺序问题。

## 过滤器、拦截器、监听器

### 前言

* 过滤器（Filter）：当有一堆请求，只希望符合预期的请求进来。
* 拦截器（Interceptor）：想要干涉预期的请求。
* 监听器（Listener）：想要监听这些请求具体做了什么。

过滤器是在请求进入容器后，但还没有进入 Servlet 之前进行预处理的。

拦截器是在请求进入控制器（Controller） 之前进行预处理的。

过滤器依赖于 Servlet 容器，而拦截器依赖于 Spring 的 IoC 容器，因此可以通过注入的方式获取容器当中的对象。

监听器用于监听 Web 应用中某些对象的创建、销毁、增加、修改、删除等动作，然后做出相应的处理。

### 过滤器

* 过滤敏感词汇（防止sql注入）
* 设置字符编码
* URL级别的权限访问控制
* 压缩响应信息

过滤器的创建和销毁都由 Web 服务器负责，Web 应用程序启动的时候，创建过滤器对象，为后续的请求过滤做好准备。

过滤器可以有很多个，一个个过滤器组合起来就成了 FilterChain，也就是过滤器链。

在 Spring 中，过滤器都默认继承了 OncePerRequestFilter，顾名思义，OncePerRequestFilter 的作用就是确保一次请求只通过一次过滤器，而不重复执行。

### 拦截器

* 登录验证，判断用户是否登录
* 权限验证，判断用户是否有权限访问资源，如校验token
* 日志记录，记录请求操作日志（用户ip，访问时间等），以便统计请求访问量
* 处理cookie、本地化、国际化、主题等
* 性能监控，监控请求处理时长等

一个拦截器必须实现 HandlerInterceptor 接口，preHandle 方法是 Controller 方法调用前执行，postHandle 是 Controller
方法正常返回后执行，afterCompletion 方法无论 Controller 方法是否抛异常都会执行。

只有 preHandle 返回 true 的话，其他两个方法才会执行。

如果 preHandle 返回 false 的话，表示不需要调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。

#### 如何配置

```java

@Configuration
public class InterceptorConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoggerInterceptor()).addPathPatterns("/**");
    }
}
```

无论是过滤器还是拦截器，都属于AOP（面向切面编程）思想的具体实现。除了这两种实现之外，还有另一种更灵活的AOP实现技术，即 Aspect。
具体可以参考AdapterLogAspect的实现。

### 监听器
