## 从 BIO 到 NIO，再到 AIO

Netty 的高性能架构，是基于一个网络编程设计模式 Reactor 进行设计的。现在，大多数与 I/O 相关的组件，都会使用 Reactor 模型，比如
Tomcat、Redis、Nginx 等，可见 Reactor 应用的广泛性。

Reactor 是 NIO 的基础。为什么 NIO 的性能就能够比传统的阻塞 I/O 性能高呢？我们首先来看一下传统阻塞式 I/O 的一些特点。

### 阻塞 I/O 模型

线程资源是非常昂贵的，除了占用大量的内存，还会占用非常多的 CPU 调度时间，所以 BIO 在连接非常多的情况下，效率会变得非常低。

BIO 的读写操作是阻塞的，线程的整个生命周期和连接的生命周期是一样的，而且不能够被复用。

就单个阻塞 I/O 来说，它的效率并不比 NIO 慢。但是当服务的连接增多，考虑到整个服务器的资源调度和资源利用率等因素，NIO
就有了显著的效果，NIO 非常适合高并发场景。

### 非阻塞 I/O 模型

其实，在处理 I/O 动作时，有大部分时间是在等待。比如，socket
连接要花费很长时间进行连接操作，在完成连接的这段时间内，它并没有占用额外的系统资源，但它只能阻塞等待在线程中。这种情况下，系统资源并不能被合理利用。

Java 的 NIO，在 Linux 上底层是使用 epoll 实现的。epoll 是一个高性能的多路复用 I/O 工具，改进了 select 和 poll 等工具的一些功能。

#### epoll

epoll 的数据结构是直接在内核上进行支持的，通过 epoll_create 和 epoll_ctl 等函数的操作，可以构造描述符（fd）相关的事件组合（event）。

这里有两个比较重要的概念：

* fd 每条连接、每个文件，都对应着一个描述符，比如端口号。内核在定位到这些连接的时候，就是通过 fd 进行寻址的。
* event 当 fd 对应的资源，有状态或者数据变动，就会更新 epoll_item 结构。在没有事件变更的时候，epoll
  就阻塞等待，也不会占用系统资源；一旦有新的事件到来，epoll 就会被激活，将事件通知到应用方。

#### epoll 相对于 select，epoll 有哪些改进？

* epoll 不再需要像 select 一样对 fd 集合进行轮询，也不需要在调用时将 fd 集合在用户态和内核态进行交换；
* 应用程序获得就绪 fd 的事件复杂度，epoll 是 O(1)，select 是 O(n)；
* select 最大支持约 1024 个 fd，epoll 支持 65535个；
* select 使用轮询模式检测就绪事件，epoll 采用通知方式，更加高效。

事件共有 4 种，分别是：

* 新连接事件（OP_ACCEPT）；
* 连接就绪事件（OP_CONNECT）；
* 读就绪事件（OP_READ）；
* 写就绪事件（OP_WRITE）。

### Reactor 模式

NIO 是基于事件机制的，有一个叫作 Selector 的选择器，阻塞获取关注的事件列表。获取到事件列表后，可以通过分发器，进行真正的数据操作。

Reactor 模型里面有四个主要元素：

* Acceptor处理 client 的连接，并绑定具体的事件处理器；
* Event具体发生的事件，比如图中s的read、send等；
* Handler执行具体事件的处理者，比如处理读写事件的具体逻辑；
* Reactor将具体的事件分配（dispatch）给 Handler。

熟悉 Netty 的同学可以看到，这个 Reactor 模型就是 Netty 设计的基础。在 Netty 中，Boss 线程对应着对连接的处理和分派，相当于
mainReactor；Worker 线程对应着 subReactor，使用多线程负责读写事件的分发和处理。

这种模式将每个组件的职责分得更细，耦合度也更低，能有效解决 C10k 问题。

### AIO

关于 NIO 的概念，误解还是比较多的。

#### 1. 使用 NIO 时，使用 Channel 进行读写，socket 的操作依然是阻塞的？

```text
// 这行代码是阻塞的
int size = sc.read(buf); 
```

NIO 只负责对发生在 fd 描述符上的事件进行通知。事件的获取和通知部分是非阻塞的，但收到通知之后的操作，却是阻塞的，即使使用多线程去处理这些事件，它依然是阻塞的。

AIO 更近一步，将这些对事件的操作也变成非阻塞的。

### 响应式编程

Spring WebFlux 的底层使用的是 Netty，所以操作是异步非阻塞的。

非阻塞的特性我们可以理解，那响应式又是什么概念呢？

响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值，通过数据流进行传播。

这段话很晦涩，在编程方面，它表达的意思就是：把生产者消费者模式，使用简单的API 表示出来，并自动处理背压（Backpressure）问题。

背压，指的是生产者与消费者之间的流量控制，通过将操作全面异步化，来减少无效的等待和资源消耗。

### 小节

* BIO 的线程模型是一个连接对应一个线程的，非常浪费资源；
* NIO通过对关键事件的监听，通过主动通知的方式完成非阻塞操作，但它对事件本身的处理依然是非阻塞的；
* AIO 完全是异步非阻塞的，但现实中使用很少。

使用 Netty 的多 Acceptor 模式和多线程模式，我们能够方便地完成类似 AIO 这样的操作。Netty 的事件触发机制使用了高效的 ET
模式，使得支持的连接更多，性能更高。

使用 Netty，能够构建响应式编程的基础，加上类似 Lambda 表达式这样的书写风格，能够完成类似 WebFlux 这样的响应式框架。





